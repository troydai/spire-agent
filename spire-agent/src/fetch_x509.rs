use std::{
    fs,
    path::Path,
    time::{Duration, Instant},
};

use anyhow::{Context, Result, anyhow};
use chrono::{DateTime, Utc};
use der::{Encode, Reader};
use pem_rfc7468::LineEnding;
use x509_cert::Certificate;

use crate::rpc::{WorkloadClient, connect_workload_client};
use crate::grpc::{
    X509svid, X509svidRequest, X509svidResponse,
};

pub async fn fetch_x509(
    socket_path: &str,
    timeout: Duration,
    silent: bool,
    write_dir: Option<&str>,
) -> Result<()> {
    let start = Instant::now();
    let mut client = connect_workload_client(socket_path).await?;
    let resp = fetch_x509svid(&mut client, timeout).await?;

    let elapsed = start.elapsed();
    let svids = resp.svids;
    if !silent {
        print_svids(&svids, elapsed)?;
    }
    if let Some(dir) = write_dir {
        write_svids(&svids, dir, silent)?;
    }

    Ok(())
}

async fn fetch_x509svid(
    client: &mut WorkloadClient,
    timeout: Duration,
) -> Result<X509svidResponse> {
    let request = tonic::Request::new(X509svidRequest {});
    let response = tokio::time::timeout(timeout, client.fetch_x509svid(request))
        .await
        .context("request timed out")?;
        .context("failed to fetch x509 svid")?;

    let mut stream = response.into_inner();
    let resp = tokio::time::timeout(timeout, stream.message())
        .await
        .context("timed out waiting for response")?;
        .context("failed to receive message")?;
        .context("empty response from server")?;

    Ok(resp)
}

fn print_svids(svids: &[X509svid], elapsed: Duration) -> Result<()> {
    println!(
        "Received {} svid after {}\n",
        svids.len(),
        format_duration_seconds(elapsed)
    );

    for svid in svids {
        print_svid(svid)?;
    }

    Ok(())
}

fn write_svids(svids: &[X509svid], write_dir: &str, silent: bool) -> Result<()> {
    let dir = Path::new(write_dir);
    if dir.exists() && !dir.is_dir() {
        anyhow::bail!("write path is not a directory: {}", dir.display());
    }
    fs::create_dir_all(dir).context("failed to create output directory")?;

    for (idx, svid) in svids.iter().enumerate() {
        let svid_path = dir.join(format!("svid.{idx}.pem"));
        let key_path = dir.join(format!("svid.{idx}.key"));
        let bundle_path = dir.join(format!("bundle.{idx}.pem"));

        let svid_pem = pem_cert_chain(&svid.x509_svid)?;
        write_pem_file(&svid_path, &svid_pem, Some(0o644))?;
        if !silent {
            println!("Writing SVID #{} to file {}.", idx, svid_path.display());
        }

        let key_pem = pem_key(&svid.x509_svid_key)?;
        write_pem_file(&key_path, &key_pem, Some(0o600))?;
        if !silent {
            println!("Writing key #{} to file {}.", idx, key_path.display());
        }

        let bundle_pem = pem_cert_chain(&svid.bundle)?;
        write_pem_file(&bundle_path, &bundle_pem, Some(0o644))?;
        if !silent {
            println!("Writing bundle #{} to file {}.", idx, bundle_path.display());
        }
    }

    Ok(())
}

fn pem_cert_chain(der_bytes: &[u8]) -> Result<String> {
    let certs = parse_cert_chain(der_bytes)?;
    let mut pem = String::new();
    for cert in certs {
        let der = cert.to_der().context("failed to encode certificate")?;
        pem.push_str(&pem_single("CERTIFICATE", &der)?);
    }
    Ok(pem)
}

fn pem_single(label: &str, der_bytes: &[u8]) -> Result<String> {
    pem_rfc7468::encode_string(label, LineEnding::LF, der_bytes)
        .map_err(|err| anyhow!("failed to encode PEM data: {err}"))
}

fn pem_key(der_bytes: &[u8]) -> Result<String> {
    pem_single("PRIVATE KEY", der_bytes)
}

fn write_pem_file(path: &Path, contents: &str, mode: Option<u32>) -> Result<()> {
    #[cfg(unix)]
    {
        use std::io::Write;
        use std::os::unix::fs::OpenOptionsExt;

        let file_mode = mode.unwrap_or(0o644);
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .mode(file_mode)
            .open(path)
            .with_context(|| format!("failed to open {}", path.display()))?;
        file.write_all(contents.as_bytes())
            .with_context(|| format!("failed to write {}", path.display()))?;
        Ok(())
    }

    #[cfg(not(unix))] 
    {
        fs::write(path, contents.as_bytes()).with_context(|| {
            format!("failed to write {}", path.display())
        })?;
        Ok(())
    }
}

fn print_svid(svid: &X509svid) -> Result<()> {
    println!("SPIFFE ID:\t\t{}", svid.spiffe_id);

    let svid_certs = parse_cert_chain(&svid.x509_svid)?;
    print_leaf_validity(&svid_certs);
    print_intermediate_validity(&svid_certs);

    let bundle_certs = parse_cert_chain(&svid.bundle)?;
    print_bundle_validity(&bundle_certs);

    Ok(())
}

fn print_leaf_validity(certs: &[Certificate]) {
    let Some(leaf) = certs.first() else {
        return;
    };

    let validity = &leaf.tbs_certificate.validity;
    let not_before = parse_x509_time(&validity.not_before);
    let not_after = parse_x509_time(&validity.not_after);
    println!("SVID Valid After:\t{}", format_utc_time(not_before));
    println!("SVID Valid Until:\t{}", format_utc_time(not_after));
}

fn print_intermediate_validity(certs: &[Certificate]) {
    let mut intermediate_num = 1;

    for cert in certs.iter().skip(1) {
        let validity = &cert.tbs_certificate.validity;
        let not_before = parse_x509_time(&validity.not_before);
        let not_after = parse_x509_time(&validity.not_after);

        println!(
            "Intermediate #{}
 Valid After:\t{}",
            intermediate_num,
            format_utc_time(not_before)
        );
        println!(
            "Intermediate #{}
 Valid Until:\t{}",
            intermediate_num,
            format_utc_time(not_after)
        );
        intermediate_num += 1;
    }
}

fn print_bundle_validity(certs: &[Certificate]) {
    let mut ca_num = 1;

    for cert in certs {
        let validity = &cert.tbs_certificate.validity;
        let not_before = parse_x509_time(&validity.not_before);
        let not_after = parse_x509_time(&validity.not_after);

        println!(
            "CA #{}
 Valid After:\t{}",
            ca_num,
            format_utc_time(not_before)
        );
        println!(
            "CA #{}
 Valid Until:\t{}",
            ca_num,
            format_utc_time(not_after)
        );
        ca_num += 1;
    }
}

fn parse_cert_chain(der_bytes: &[u8]) -> Result<Vec<Certificate>> {
    let mut certs = Vec::new();
    let mut reader = der::SliceReader::new(der_bytes).context("failed to create DER reader")?;

    while !reader.is_finished() {
        let cert = reader
            .decode::<Certificate>()
            .context("failed to parse certificate")?;
        certs.push(cert);
    }

    Ok(certs)
}

fn parse_x509_time(time: &x509_cert::time::Time) -> DateTime<Utc> {
    match time {
        x509_cert::time::Time::UtcTime(ut) => {
            let unix = ut.to_unix_duration().as_secs() as i64;
            DateTime::from_timestamp(unix, 0).unwrap_or_default()
        }
        x509_cert::time::Time::GeneralTime(gt) => {
            let unix = gt.to_unix_duration().as_secs() as i64;
            DateTime::from_timestamp(unix, 0).unwrap_or_default()
        }
    }
}

fn format_utc_time(time: DateTime<Utc>) -> String {
    time.format("%Y-%m-%d %H:%M:%S +0000 UTC").to_string()
}

fn format_duration_seconds(duration: Duration) -> String {
    if duration.is_zero() {
        return "0s".to_string();
    }

    let seconds = duration.as_secs_f64();
    let mut out = format!("{seconds:.2}");
    while out.ends_with('0') {
        out.pop();
    }
    if out.ends_with('.') {
        out.pop();
    }
    out.push('s');
    out
}

#[cfg(test)]
mod tests {
    use std::time::Duration;

    use super::{format_duration_seconds, parse_cert_chain};

    const CERT1_DER: &[u8] = &
        [
            0x30, 0x82, 0x02, 0x9c, 0x30, 0x82, 0x01, 0x84, 0x02, 0x09, 0x00, 0xb5, 0x4c, 0x0d, 0x2d,
            0xdd, 0x7b, 0xc8, 0x37, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
            0x01, 0x0b, 0x05, 0x00, 0x30, 0x10, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x03,
            0x0c, 0x05, 0x74, 0x65, 0x73, 0x74, 0x31, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x36, 0x30, 0x31,
            0x32, 0x39, 0x30, 0x36, 0x32, 0x38, 0x30, 0x37, 0x5a, 0x17, 0x0d, 0x32, 0x36, 0x30, 0x31,
            0x33, 0x30, 0x30, 0x36, 0x32, 0x38, 0x30, 0x37, 0x5a, 0x30, 0x10, 0x31, 0x0e, 0x30, 0x0c,
            0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x05, 0x74, 0x65, 0x73, 0x74, 0x31, 0x30, 0x82, 0x01,
            0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
            0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00,
            0xaa, 0xe7, 0xce, 0xc1, 0x1e, 0x48, 0xe2, 0x10, 0x51, 0x2b, 0x7b, 0x49, 0x69, 0x0b, 0x66,
            0xc2, 0xa0, 0x8c, 0xbb, 0x9f, 0x86, 0x8d, 0xc5, 0x91, 0xc2, 0x00, 0x2a, 0x26, 0x42, 0xe7,
            0xc3, 0x56, 0x33, 0xfb, 0x83, 0x2c, 0x38, 0x79, 0x81, 0xc1, 0xa5, 0x78, 0x01, 0x19, 0x17,
            0x9d, 0x1f, 0x36, 0x8f, 0xe0, 0x96, 0x15, 0xd6, 0x19, 0xdd, 0x53, 0xe0, 0x01, 0x9f, 0xa7,
            0x83, 0x5a, 0x50, 0xcd, 0x51, 0x09, 0x4f, 0xde, 0xbf, 0x54, 0xc9, 0x36, 0x9c, 0x47, 0x4f,
            0x48, 0xf8, 0xca, 0x89, 0x11, 0x87, 0xdf, 0xb0, 0x73, 0xae, 0x52, 0x02, 0xf9, 0xeb, 0xe2,
            0xf5, 0x99, 0x04, 0xf2, 0x34, 0x45, 0xa4, 0x94, 0xf1, 0xb9, 0xe5, 0x67, 0x37, 0xae, 0x64,
            0x3f, 0xf3, 0x37, 0xbb, 0x13, 0x18, 0x14, 0x25, 0xc0, 0x81, 0x53, 0x67, 0x23, 0x5b, 0xb6,
            0xee, 0xac, 0xe6, 0x72, 0x77, 0x7f, 0xd6, 0x80, 0xbb, 0x2d, 0x3e, 0x2b, 0x89, 0x82, 0xe7,
            0x00, 0x7d, 0xe3, 0x5f, 0x2f, 0x8a, 0x36, 0xad, 0x32, 0xed, 0x98, 0xfc, 0xc4, 0x87, 0x08,
            0x70, 0x65, 0x3a, 0xd0, 0x8c, 0x0a, 0x46, 0x87, 0xd4, 0x2d, 0xc9, 0x23, 0x42, 0x0f, 0x47,
            0x87, 0xb6, 0xd9, 0x67, 0xcb, 0xd5, 0x22, 0x29, 0x68, 0x8e, 0xf6, 0x48, 0xd4, 0x53, 0x21,
            0xda, 0xfb, 0xc7, 0x1e, 0x33, 0x65, 0x8b, 0x42, 0xa9, 0x9e, 0xc2, 0xca, 0xaf, 0xe5, 0x4c,
            0x17, 0x94, 0x5c, 0x8c, 0x81, 0xb3, 0x9e, 0x82, 0x4f, 0xe5, 0x31, 0x64, 0xc9, 0x13, 0x9b,
            0xb2, 0xaf, 0x36, 0xe4, 0x50, 0xbf, 0xf3, 0xfb, 0x58, 0x59, 0x5b, 0xc9, 0x3e, 0x55, 0x7b,
            0xa3, 0xee, 0xce, 0xae, 0x7e, 0xf1, 0xfa, 0xbc, 0x43, 0x47, 0x02, 0xf1, 0x36, 0xce, 0x3b,
            0xb7, 0x71, 0x54, 0x61, 0x4d, 0x51, 0xc9, 0x90, 0x02, 0xc3, 0x7c, 0xd2, 0x2f, 0x45, 0x2f,
            0x75, 0x02, 0x03, 0x01, 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
            0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x95, 0xf7, 0x17, 0x79,
            0xc4, 0x8d, 0x34, 0x1e, 0x22, 0x35, 0x62, 0x78, 0x9b, 0xd2, 0xd3, 0x81, 0x7f, 0x65, 0xff,
            0x9d, 0x20, 0xe7, 0x08, 0x29, 0x77, 0xb4, 0xa9, 0x08, 0x0b, 0xf3, 0xa1, 0x0e, 0xc7, 0xa9,
            0x7e, 0xb1, 0x22, 0xfa, 0x0f, 0x54, 0x48, 0x4d, 0x01, 0x80, 0x4e, 0xfe, 0xd6, 0xa3, 0x01,
            0x0f, 0x4d, 0xd1, 0xda, 0xc7, 0xfa, 0x0d, 0xcf, 0xe2, 0xfe, 0x91, 0xc9, 0x91, 0x95, 0xb8,
            0x0a, 0x96, 0xaf, 0x90, 0x17, 0x57, 0x3a, 0x27, 0xb7, 0xf3, 0x0f, 0x2f, 0x4a, 0xdc, 0xd7,
            0x2e, 0x29, 0x0e, 0x9f, 0xcd, 0x18, 0xe0, 0x40, 0x26, 0x46, 0x65, 0x10, 0xd3, 0xf6, 0x87,
            0x7a, 0xb2, 0xe2, 0xde, 0xc0, 0xd6, 0x9c, 0x45, 0xf9, 0x03, 0xcc, 0xbd, 0x0f, 0x00, 0x4e,
            0x5f, 0x30, 0xc6, 0x90, 0x21, 0xb0, 0x53, 0x23, 0xe3, 0xc9, 0x7a, 0xcd, 0xd7, 0xfa, 0xde,
            0x34, 0x9d, 0x03, 0xf9, 0x57, 0x4c, 0x88, 0x6c, 0xd3, 0x62, 0x5f, 0x78, 0x45, 0x5a, 0x95,
            0x53, 0x1f, 0xa5, 0xa4, 0xdc, 0x9d, 0xf6, 0xb6, 0xf2, 0x83, 0x32, 0x3d, 0x28, 0x1d, 0xd5,
            0xf9, 0x26, 0xfe, 0xce, 0x69, 0x09, 0x5a, 0x0d, 0xaa, 0x38, 0x10, 0x16, 0xe5, 0x58, 0x62,
            0x8b, 0xfc, 0x11, 0x38, 0x1b, 0xf0, 0x25, 0x05, 0xaf, 0x06, 0x3e, 0x57, 0x66, 0x69, 0x48,
            0x5f, 0x8c, 0x48, 0x87, 0x64, 0x28, 0xd6, 0x8e, 0x57, 0x74, 0x66, 0x03, 0xdf, 0x59, 0x74,
            0x18, 0x39, 0xd0, 0x5c, 0x8f, 0x61, 0xaa, 0x35, 0x3f, 0x8c, 0x10, 0xa2, 0xd5, 0xff, 0xb7,
            0x48, 0xa4, 0x1d, 0xc3, 0x99, 0x51, 0x9e, 0x8d, 0xdb, 0xe4, 0x72, 0xbd, 0x1f, 0x4a, 0x02,
            0x17, 0x9e, 0xeb, 0xc9, 0x2a, 0x4e, 0xcc, 0x9f, 0x41, 0x95, 0x4d, 0xb7, 0x19, 0x6b, 0x4e,
            0x6a, 0x3d, 0xa9, 0x6e, 0xaa, 0xc7, 0xed, 0x95, 0xa5, 0xce, 0xd4, 0x72,
        ];
    const CERT2_DER: &[u8] = &
        [
            0x30, 0x82, 0x02, 0x9c, 0x30, 0x82, 0x01, 0x84, 0x02, 0x09, 0x00, 0x8a, 0x93, 0xa4, 0x38,
            0x6c, 0x7b, 0xc6, 0xc6, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
            0x01, 0x0b, 0x05, 0x00, 0x30, 0x10, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x03,
            0x0c, 0x05, 0x74, 0x65, 0x73, 0x74, 0x32, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x36, 0x30, 0x31,
            0x32, 0x39, 0x30, 0x36, 0x32, 0x38, 0x30, 0x37, 0x5a, 0x17, 0x0d, 0x32, 0x36, 0x30, 0x31,
            0x33, 0x30, 0x30, 0x36, 0x32, 0x38, 0x30, 0x37, 0x5a, 0x30, 0x10, 0x31, 0x0e, 0x30, 0x0c,
            0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x05, 0x74, 0x65, 0x73, 0x74, 0x32, 0x30, 0x82, 0x01,
            0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
            0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00,
            0xc1, 0x3c, 0xcc, 0x97, 0x41, 0x59, 0xb4, 0x58, 0xaa, 0x2d, 0x44, 0xd4, 0xe1, 0xd0, 0x3d,
            0x15, 0xd0, 0xe9, 0x08, 0x79, 0x93, 0x7f, 0x90, 0x0c, 0xf3, 0x6f, 0xd8, 0x2c, 0x18, 0x3c,
            0x81, 0xfe, 0x5e, 0x66, 0xc6, 0x95, 0x5d, 0x5d, 0xe1, 0x20, 0xa6, 0xbc, 0xa6, 0xcc, 0x65,
            0x5d, 0x85, 0xfe, 0x4a, 0x4a, 0x39, 0x81, 0x24, 0x3d, 0xc7, 0x52, 0xa7, 0x7a, 0xfa, 0x78,
            0xe4, 0xb7, 0x9c, 0x54, 0x14, 0x31, 0x87, 0x56, 0x81, 0x50, 0xe0, 0x57, 0x33, 0x9f, 0x1d,
            0xbe, 0xa4, 0x3c, 0x3b, 0xe5, 0x2a, 0x90, 0x9b, 0xb0, 0x54, 0x0a, 0xb0, 0x85, 0xb3, 0xbd,
            0x66, 0x4e, 0x14, 0x76, 0x1d, 0x7c, 0x89, 0x66, 0x7b, 0xc4, 0x17, 0xed, 0xdc, 0x97, 0x49,
            0x20, 0x1e, 0xb2, 0x63, 0x63, 0x02, 0xaf, 0x90, 0x75, 0xcd, 0xe1, 0x38, 0xc5, 0xa7, 0xe7,
            0x9a, 0xaa, 0xaf, 0x19, 0x5b, 0xc3, 0xd8, 0x9e, 0x41, 0xaa, 0xb0, 0x97, 0x16, 0x59, 0x32,
            0xba, 0xe4, 0x6a, 0xb6, 0x66, 0xa4, 0xbb, 0x2a, 0x84, 0x0a, 0xb4, 0xf7, 0xa1, 0x61, 0x79,
            0xee, 0x6d, 0xe7, 0xae, 0x29, 0x1e, 0x1a, 0x4a, 0xd7, 0x7e, 0x45, 0x72, 0x2e, 0xa7, 0xd4,
            0x27, 0xa6, 0x51, 0xb6, 0x68, 0xc0, 0x84, 0x1c, 0xe1, 0x73, 0x8c, 0x33, 0x3a, 0x56, 0x98,
            0x7e, 0xfd, 0xd6, 0xe3, 0xbd, 0xa4, 0xb1, 0xb8, 0xe0, 0x97, 0xb5, 0x34, 0x85, 0x0e, 0x7a,
            0x33, 0x70, 0x29, 0x28, 0xe4, 0x78, 0xa7, 0x1a, 0xac, 0x15, 0xa3, 0x67, 0x14, 0x13, 0x58,
            0x15, 0xee, 0xbd, 0x61, 0xf9, 0xf7, 0x2e, 0x1b, 0x02, 0x92, 0xec, 0x98, 0x71, 0x21, 0x65,
            0x25, 0x5e, 0x48, 0xd3, 0x89, 0x03, 0x33, 0x34, 0x52, 0xe5, 0xac, 0xc3, 0xe3, 0xb2, 0x1f,
            0xc3, 0x9b, 0xb4, 0xd5, 0x50, 0xd9, 0x88, 0x18, 0x6e, 0x84, 0xf8, 0x5a, 0xcb, 0xd0, 0x87,
            0xbd, 0x02, 0x03, 0x01, 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
            0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x5f, 0x2c, 0x35, 0xb8,
            0x89, 0xcc, 0xe1, 0x4f, 0x76, 0xde, 0xf7, 0x54, 0xfb, 0x0c, 0x8d, 0xf7, 0x87, 0xe2, 0x25,
            0xad, 0x71, 0xea, 0x17, 0xc8, 0xd2, 0x00, 0x3b, 0xf8, 0x9b, 0x4b, 0x4a, 0x75, 0xcf, 0xd8,
            0x7e, 0xf0, 0x45, 0x79, 0xdf, 0x6e, 0x6a, 0x8b, 0x1a, 0x7c, 0x8e, 0x57, 0x29, 0x10, 0xdd,
            0x8b, 0x36, 0x50, 0x2e, 0xef, 0xa9, 0xff, 0x5e, 0xc8, 0x03, 0x1c, 0xdd, 0x42, 0xbf, 0xc3,
            0xb5, 0x1f, 0x51, 0xad, 0xc6, 0xe5, 0xa4, 0x90, 0x6b, 0xd8, 0x8d, 0xbd, 0xab, 0x97, 0x42,
            0x00, 0x9b, 0x14, 0xfd, 0x16, 0x5d, 0xf9, 0x37, 0xfd, 0x19, 0x7f, 0xd8, 0x21, 0x7a, 0x5f,
            0xb5, 0x14, 0x11, 0x3d, 0x8e, 0x5b, 0xcf, 0x3b, 0xe3, 0x15, 0xf9, 0xd6, 0xd6, 0xd3, 0x8c,
            0x4f, 0x29, 0x81, 0xb0, 0x1b, 0x8b, 0x43, 0xd1, 0x03, 0xcf, 0x40, 0x75, 0xfe, 0xba, 0xf8,
            0x07, 0x8b, 0xa3, 0x70, 0x02, 0x71, 0x94, 0x81, 0x83, 0x46, 0x70, 0xcc, 0x39, 0x33, 0x44,
            0x19, 0x93, 0x25, 0xa4, 0xeb, 0x41, 0x34, 0x4a, 0x45, 0x9a, 0xa8, 0xaa, 0x95, 0xba, 0x9d,
            0x82, 0x1d, 0x80, 0x3b, 0x3e, 0x3b, 0xd9, 0xc0, 0x30, 0x86, 0x6b, 0x6a, 0x3d, 0x6f, 0x93,
            0xfd, 0x63, 0xae, 0x89, 0x40, 0xed, 0x94, 0x3c, 0x59, 0x8a, 0x4e, 0xb3, 0x9f, 0xed, 0xc1,
            0x6b, 0x16, 0x63, 0xfe, 0x07, 0xc8, 0x6c, 0x13, 0x63, 0xe5, 0xc4, 0xd3, 0x8d, 0xe5, 0x36,
            0x13, 0x82, 0x23, 0xe0, 0x49, 0x06, 0x2c, 0x35, 0x30, 0xda, 0x79, 0x7d, 0x1d, 0xc7, 0xff,
            0xbf, 0x72, 0x6a, 0xad, 0x5a, 0x89, 0x4c, 0x39, 0xed, 0x55, 0x6b, 0x00, 0xe1, 0x39, 0x44,
            0xe4, 0xf9, 0x91, 0x45, 0xb1, 0x8e, 0x82, 0xb3, 0x9e, 0x71, 0x58, 0x1c, 0x86, 0xda, 0xed,
            0xf5, 0xe4, 0x5b, 0xae, 0x91, 0xa9, 0x1a, 0xc3, 0x57, 0x2e, 0x4b, 0x34,
        ];

    #[test]
    fn parse_cert_chain_reads_concatenated_certs() {
        let mut chain = Vec::with_capacity(CERT1_DER.len() + CERT2_DER.len());
        chain.extend_from_slice(CERT1_DER);
        chain.extend_from_slice(CERT2_DER);

        let certs = parse_cert_chain(&chain).expect("valid chain");
        assert_eq!(certs.len(), 2);
    }

    #[test]
    fn format_duration_seconds_normalizes_to_seconds() {
        assert_eq!(format_duration_seconds(Duration::ZERO), "0s");
        assert_eq!(format_duration_seconds(Duration::from_nanos(1)), "0s");
        assert_eq!(
            format_duration_seconds(Duration::from_millis(123)),
            "0.12s"
        );
        assert_eq!(
            format_duration_seconds(Duration::from_secs(1) + Duration::from_millis(234)),
            "1.23s"
        );
        assert_eq!(format_duration_seconds(Duration::from_secs(60)), "60s");
    }
}